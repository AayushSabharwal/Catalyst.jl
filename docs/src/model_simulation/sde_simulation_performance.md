# [Advice for performant SDE simulations](@id sde_simulation_performance)
While there exist relatively straightforward approaches to improve performance for [ODE](@ref ref) and [Jump](@ref ref) simulations, this is generally not the case for SDE simulations. Below, we briefly describe some options. However, as one starts to investigate these, one quickly reaches what is (or could be) active areas of research.

## [SDE solver selection](@id sde_simulation_performance_solvers)
We have previously described [how ODE solver selection](@ref ref) can impact simulation performance. Again, it can be worthwhile to investigate this for SDE simulations. Throughout this documentation, we generally use the `STrapezoid` solver as the default choice. However, if the `DifferentialEquations` package is loaded
```julia
using DifferentialEquations
```
automatic SDE solver selection is automatically enabled (just like is the case for ODEs by default). Generally, the automatic SDe solver choice enabled by `DifferentialEquations` is better than just using `STrapezoid`. Next, if performance is critical, it can be worthwhile to check the [list of available SDE solvers](https://docs.sciml.ai/DiffEqDocs/stable/solvers/sde_solve/) to find one with advantageous performance for a given problem. When doing so, it is important to pick a solver compatible with *non-diagonal noise* and with [*Ito problems*](https://en.wikipedia.org/wiki/It%C3%B4_calculus). 

## [Options for Jacobian computation](@id sde_simulation_performance_jacobian)
In [the section on ODE simulation performance](@ref ref) we describe various options for computing the system Jacobian, and how these could be used to improve performance for [implicit solvers](@ref ref). These can be used in tandem with implicit SDE solvers (such as `ImplicitEM`). However, due to additional considerations during SDE simulations, it is much less certain whether these will actually have any impact on performance. So while these options might be worth reading about and trialling, there is no guarantee that they will be beneficial.

## [Parallelisation on CPUs and GPUs](@id sde_simulation_performance_parallelisation)
We have previously described how simulation parallelisation can be used to [improve performance when multiple ODE simulations are carried out](@ref ref). The same approaches can be used for SDE simulations. Indeed, it is often more relevant for SDEs, as these often are re-simulated using identical simulation conditions (to investigate their typical behaviour across many samples). CPU parallelisation of SDE simulations uses the same approach as for ODEs. For GPU parallelisation we

### [Multilevel Monte Carlo](@id sde_simulation_performance_parallelisation_mlmc)
An approach for speeding up parallel stochastic simulations are so-called [*multilevel Monte Carlo approaches*](https://en.wikipedia.org/wiki/Multilevel_Monte_Carlo_method) (MLMC). These are used when a stochastic process is simulated repeatedly using identical simulation conditions. Here, instead of performing all simulations using identical tolerance, the ensemble is simulated using a range of tolerances (primarily lower ones, which yields faster simulations). Currently, [StochasticDiffEq.jl](https://github.com/SciML/StochasticDiffEq.jl) do not have a native implementation for performing MLMC simulations (this will hopefully be added in the future). However, if high performance of parallel SDE simulations is required, these approaches may be worth investigating.
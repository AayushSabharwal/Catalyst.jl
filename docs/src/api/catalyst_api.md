# Catalyst.jl API
```@meta
CurrentModule = Catalyst
```

## Reaction network generation and representation
Catalyst provides the [`@reaction_network`](@ref) macro for generating a
complete network, stored as a [`ReactionSystem`](@ref), which in turn is
composed of [`Reaction`](@ref)s. `ReactionSystem`s can be converted to other
`ModelingToolkit.AbstractSystem`s, including a `ModelingToolkit.ODESystem`,
`ModelingToolkit.SDESystem`, or `ModelingToolkit.JumpSystem`.

An empty network can be generated using [`@reaction_network`](@ref) with no
arguments (or one argument to name the system), or the
[`make_empty_network`](@ref) function. These can then be extended
programmatically using [`addspecies!`](@ref), [`addparam!`](@ref), and
[`addreaction!`](@ref).

When using the [`@reaction_network`](@ref) macro, Catalyst will automatically
attempt to detect what is a species and what is a parameter. Everything that
appear as a substrate or product in some reaction will be treated as a species,
while all remaining symbols will be considered parameters (corresponding to
those symbols that only appear within rate expressions and/or as stoichiometric
coefficients). I.e. in
```julia
rn = @reaction_network begin
    k*X, Y --> W
end
```
`Y` and `W` will all be classified as chemical species, while `k` and `X` will be classified as parameters.

The [`ReactionSystem`](@ref) generated by the [`@reaction_network`](@ref) macro
is a `ModelingToolkit.AbstractSystem` that symbolically represents a system of
chemical reactions. In some cases it can be convenient to bypass the macro and
directly generate a collection of [`Reaction`](@ref)s and a corresponding
[`ReactionSystem`](@ref) encapsulating them. Below we illustrate with a simple
SIR example how a system can be directly constructed, and demonstrate how to
then generate from the [`ReactionSystem`](@ref) and solve corresponding chemical
reaction ODE models, chemical Langevin equation SDE models, and stochastic
chemical kinetics jump process models.

```julia
using Catalyst, OrdinaryDiffEq, StochasticDiffEq, JumpProcesses
@parameters β γ t
@variables S(t) I(t) R(t)

rxs = [Reaction(β, [S,I], [I], [1,1], [2])
       Reaction(γ, [I], [R])]
@named rs = ReactionSystem(rxs, t)

u₀map    = [S => 999.0, I => 1.0, R => 0.0]
parammap = [β => 1/10000, γ => 0.01]
tspan    = (0.0, 250.0)

# solve as ODEs
odesys = convert(ODESystem, rs)
oprob = ODEProblem(odesys, u₀map, tspan, parammap)
sol = solve(oprob, Tsit5())

# solve as SDEs
sdesys = convert(SDESystem, rs)
sprob = SDEProblem(sdesys, u₀map, tspan, parammap)
sol = solve(sprob, EM(), dt=.01)

# solve as jump process
jumpsys = convert(JumpSystem, rs)
u₀map    = [S => 999, I => 1, R => 0]
dprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)
jprob = JumpProblem(jumpsys, dprob, Direct())
sol = solve(jprob, SSAStepper())
```


```@docs
@reaction_network
make_empty_network
@reaction
Reaction
ReactionSystem
```

## ModelingToolkit and Catalyst accessor functions
A [`ReactionSystem`](@ref) is an instance of a
`ModelingToolkit.AbstractTimeDependentSystem`, and has a number of fields that
can be accessed using the Catalyst API and the [ModelingToolkit.jl Abstract
System Interface](https://docs.sciml.ai/ModelingToolkit/stable/basics/AbstractSystem/). Below we
overview these components.

There are three basic sets of convenience accessors that will return information
either from a top-level system, the top-level system and all sub-systems that
are also `ReactionSystem`s (i.e. the full reaction-network), or the top-level
system, all subs-systems, and all constraint systems (i.e. the full model). To
retrieve info from just a base [`ReactionSystem`](@ref) `rn`, ignoring
sub-systems of `rn`, one can use the ModelingToolkit accessors (these provide
direct access to the corresponding internal fields of the `ReactionSystem`)

* `get_states(rn)` is a vector that collects all the species defined within
  `rn`.
* `get_ps(rn)` is a vector that collects all the parameters defined *within*
  reactions in `rn`.
* `get_eqs(rn)` is a vector that collects all the [`Reaction`](@ref)s defined
  within `rn`.
* `get_iv(rn)` is the independent variable used in the system (usually `t` to
  represent time).
* `get_systems(rn)` is a vector of all sub-systems of `rn`.
* `get_defaults(rn)` is a dictionary of all the default values for parameters
  and species in `rn`.

These are complemented by the Catalyst accessor

* `Catalyst.get_constraints(sys)` is the constraint system of `rn`. If
  none is defined will return `nothing`.

The preceding accessors do not allocate, directly accessing internal fields of
the `ReactionSystem`.

To retrieve information from the full reaction network represented by a
system `rn`, which corresponds to information within both `rn` and all
sub-systems of type `ReactionSystem`, one can call:

* [`species(rn)`](@ref) is a vector collecting all the chemical species within
  the system and any sub-systems that are also `ReactionSystems`.
* [`reactionparams(rn)`](@ref) is a vector of all the parameters within the
  system and any sub-systems that are also `ReactionSystem`s. These include all
  parameters that appear within some `Reaction`.
* [`reactions(rn)`](@ref) is a vector of all the `Reaction`s within the system
  and any sub-systems that are also `ReactionSystem`s.

These accessors will allocate unless there are no subsystems. In the latter case
they are equivalent to the corresponding `get_*` functions.

Finally, as some sub-systems may be other system types, for example specifying
algebraic constraints with a `NonlinearSystem`, it can also be convenient to
collect all state variables (e.g. species and algebraic variables) and such. The
following ModelingToolkit functions provide this information

* `ModelingToolkit.states(rn)` returns all species *and variables*
  across the system, *all sub-systems*, and all constraint systems.
* `ModelingToolkit.parameters(rn)` returns all parameters across the
  system, *all sub-systems*, and all constraint systems.
* `ModelingToolkit.equations(rn)` returns all [`Reaction`](@ref)s and all
  `Equations` defined across the system, *all sub-systems*, and all constraint
  systems.

`states` and `parameters` should be assumed to always allocate, while
`equations` will allocate unless there are no subsystems or constraint systems.
In the latter case `equations` is equivalent to `get_eqs`.

Below we list the remainder of the Catalyst API accessor functions mentioned
above.

## Basic system properties
See [Programmatic Construction of Symbolic Reaction Systems](@ref programmatic_CRN_construction) for examples and [ModelingToolkit and
Catalyst Accessor Functions](@ref) for more details on the basic accessor
functions.

```@docs
species
reactionparams
reactions
numspecies
numreactions
numreactionparams
speciesmap
paramsmap
reactionparamsmap
Catalyst.isconstant
Catalyst.isbc
```

## Basic reaction properties
```@docs
ismassaction
dependents
dependants
substoichmat
prodstoichmat
netstoichmat
reactionrates
```

## Functions to extend or modify a network
`ReactionSystem`s can be programmatically extended using [`addspecies!`](@ref),
[`addparam!`](@ref), [`addreaction!`](@ref), [`@add_reactions`](@ref), or
composed using [`ModelingToolkit.extend`](@ref) and
[`ModelingToolkit.compose`](@ref).

```@docs
@add_reactions
addspecies!
reorder_states!
addparam!
addreaction!
setdefaults!
ModelingToolkit.extend
ModelingToolkit.compose
Catalyst.flatten
merge!(network1::ReactionSystem, network2::ReactionSystem)
```

## Network analysis and representations
Note, currently API functions for network analysis and conservation law analysis
do not work with constant species (currently only generated by SBMLToolkit).

```@docs
conservationlaws
conservedquantities
conservedequations
conservationlaw_constants
ReactionComplexElement
ReactionComplex
reactioncomplexmap
reactioncomplexes
incidencemat
complexstoichmat
complexoutgoingmat
incidencematgraph
linkageclasses
deficiency
subnetworks
linkagedeficiencies
isreversible
isweaklyreversible
reset_networkproperties!
```

## Network comparison
```@docs
==(rn1::Reaction, rn2::Reaction)
isequal_ignore_names
==(rn1::ReactionSystem, rn2::ReactionSystem)
```

## Network visualization
[Latexify](https://korsbo.github.io/Latexify.jl/stable/) can be used to convert
networks to LaTeX mhchem equations by
```julia
using Latexify
latexify(rn)
```

If [Graphviz](https://graphviz.org/) is installed and commandline accessible, it
can be used to create and save network diagrams using [`Graph`](@ref) and
[`savegraph`](@ref).
```@docs
Graph
complexgraph
savegraph
```

## Rate laws
As the underlying [`ReactionSystem`](@ref) is comprised of `ModelingToolkit`
expressions, one can directly access the generated rate laws, and using
`ModelingToolkit` tooling generate functions or Julia `Expr`s from them.
```@docs
oderatelaw
jumpratelaw
mm
mmr
hill
hillr
hillar
```

## Transformations
```@docs
Base.convert
ModelingToolkit.structural_simplify
```

## Unit validation
```@docs
validate(rx::Reaction; info::String = "")
validate(rs::ReactionSystem, info::String="")
```

## Utility functions
```@docs
symmap_to_varmap
```
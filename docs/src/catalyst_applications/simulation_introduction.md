# [Model Simulation Introduction](@id simulation_intro)
Catalyst's core functionality is the creation of chemical reaction network (CRN) models that can be simulated using ODE, SDE, and jump simulations. How such simulations are carried out have already been described in [Catalyst's introduction](@ref introduction_to_catalyst). This page provides a deeper introduction, giving some additional background and introducing various simulation-related options. 

Here we will focus on the basics, with other sections of the simulation documentation describing various specialised features, or giving advice on performance. Anyone who plans on using Catalyst's simulation function extensively is recommended to also read the documentation on [solution plotting](@ref ref), and on how to [interact with simulation problems, integrators, and solutions]. Anyone with an application for which performance is critical should consider reading the corresponding page on performance advice for [ODEs](@ref ref), [SDEs](@ref ref), or [jump simulations](@ref ref).

### [Background to CRN simulations](@id simulation_intro_theory)
This section provides some brief theory on CRN simulations. For details of how to carry out these simulations in actual code, please skip to the following sections.

CRNs are defined by a set of *species* (with the quantities of these determining the system's state during simulations) and a set of *reaction events* (rules for how the state of the system changes). In reality, the species amounts are *discrete copy-numbers*, describing the exact numbers of that species present in the system (in systems biology this can e.g. be the number of a specific molecule present in a cell). Given rates for these reaction events, *stochastic chemical kinetics* provides a formula for simulating the system, recreating the real reaction process. During stochastic chemical kinetics simulation, the system's state is defined by discrete copy-numbers (denoting the number of each species present in the system). Next, at the occurrence of individual *reaction events*, the system's state is updated according to the occurred reaction. The result is a stochastic process (the most well-known approach for simulating these is [Gillespie's algorithm](https://en.wikipedia.org/wiki/Gillespie_algorithm)).

In practise, these jump simulations are computationally expensive. In many cases, copy-numbers are so large that they can be approximated as *continuous concentrations*, and the time-development of the system as a *deterministic process*. This creates an ordinary differential equation (ODE), and is the chemical reaction network form most familiar to people. The rule for how ODEs are generated from CRNs is called the *reaction rate equation* (RRE). Here the rate of change in a species X is:

Here, the *reaction rate equation* enables fast simulation of deterministic CRNs, while *stochastic chemical kinetics* enables exact, stochastic, simulated of the full process. An intermediary approach is to use the *chemical Langevin equations* to formulate a stochastic differential equation (SDE). This approximate the system's state as continuous concentrations, but does not assume that its time development is deterministic. Generally, it is valid when copy-numbers are large enough that the continuous approximation holds, but not so large that the system's behaviour is deterministic. Generally, the advantage of SDE simulations (compared to jump ones) is that they are faster. Also, since the system state is continuous, interpretation of e.g. stability and steady state results from the deterministic (also continuous) domain as easier for SDEs (however one should be careful of these).

The different approaches are summed up in the following table:

Interpretation | Reaction rate equation | Chemical Langevin equation | Stochastic chemical kinetics 
Simulation form | ODE simulations | SDE simulations | Jump simulations
Simulation methods examples | Euler, Runge-Kutta | Euler-Maruyama, Milstein | Gillespie, Rejection sampling
Amount | Concentration | Concentration | Copy-numbers
Deterministic/Stochastic | Deterministic | Stochastic | Stochastic
When it is applicable | Species amounts large | Species amounts moderate or large | Any species amounts
(Typical) Simulation speed | Fast | Intermediate | Slow
Simulation package | [OrdinaryDiffEq.jl](https://github.com/SciML/OrdinaryDiffEq.jl) | [StochasticDiffEq.jl](https://github.com/SciML/StochasticDiffEq.jl) | [JumpProcesses.jl](https://github.com/SciML/JumpProcesses.jl)

## [Performing ODE simulations using the reaction rate equation](@id simulation_intro_ODEs)
Below we introduce how to simulate Catalyst models with ODEs as generated by the reaction rate equation. All simulations are performed using the [OrdinaryDiffEq.jl](https://github.com/SciML/OrdinaryDiffEq.jl) package, which full documentation can be found [here](https://docs.sciml.ai/OrdinaryDiffEq/stable/). To perform any CRN simulation, we must first define our model, as well as simulation initial conditions, time span, and parameter values. Here we will use a simple [Brusselator](https://en.wikipedia.org/wiki/Brusselator) model as example: 
```@example simulation_intr_1
using Catalyst
brusselator = @reaction_network begin
    A, ∅ --> X
    1, 2X + Y --> 3X
    B, X --> Y
    1, X --> ∅
end
u0 = [:X => 1, :Y => 10]
tspan = (0.0, 50.0)
ps = [:A => 1.0, :B => 4.0]
nothing # hide
```
To simulate the model we first bundle these up into an `ODEProblem`:
```@example simulation_intr_1
oprob = ODEProblem(brusselator, u0, tspan, ps)
nothing # hide
```
Next, we can simulate the model. This requires loading the [OrdinaryDiffEq.jl](https://github.com/SciML/OrdinaryDiffEq.jl) package (used for all Catalyst ODE simulations). The simulation is performed using the `solve` function.
```@example simulation_intr_1
using OrdinaryDiffEq
sol = solve(oprob)
nothing # hide
```
Finally, the result can be plotted using the [Plots.jl](https://github.com/JuliaPlots/Plots.jl) package's `plot` function:
```@example simulation_intr_1
using Plots
plot(sol)
```
More information on how to interact with the solution object is provided [here](@ref simulation_structure_interfacing).

Some additional considerations:
- If a model without parameters have been declared, only the first three arguments must be provided to `ODEProblem`.
- While the first value of `tspan` will almost always be `0.0`, other starting times (both negative and positive) are possible.
- A discussion of various ways to represent species and parameters when designating their values can be found [here](@ref ref). 


### [Providing solver options](@id simulation_intro_solver_options)
While good defaults are generally selected, OrdinaryDiffEq enables the user to designate a long range of options to `solve` to customise the simulation. The most important is the ode simulation algorithm. These are provided as a second argument to the `solve` command. E.g. to designate that the `Tsit5` method should be used, use:
```@example simulation_intr_1
sol = solve(oprob, Rodas5P())
nothing # hide
```
A full list of available solvers are available [here](https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). An in-depth discussion on optimal solver choice is provided [here](@ref ref).

Additional arguments can be provided as keyword arguments. E.g. the `adaptive` arguments determine whether adaptive time-stepping is used (for algorithms that permits this). This defaults to `true`, but can be disabled using
```@example simulation_intr_1
sol = solve(oprob; adaptive=false)
nothing # hide
```

Here follows a list of solver options which might be of interest to the user.
- `adaptive`: Toggles adaptive timestepping for appropriate methods. Default to `true`.
- `dt`: For non-adaptive simulations, sets the step size (also sets the initial step size for non-adaptive methods).
- `saveat`: Determines the time interval at which the simulation is saved. E.g. for `saveat=2.0` the simulation is saved every second time unit. If not given, the solution is saved after each time step.
- `save_idxs`: Provides a list of species which values should be saved during the simulation. E.g. for `save_idxs=[:X]`, only the value of species $X$ is saved. 
- `maxiters`: The maximum number of timesteps of the simulation. If this number is reached, the simulation is terminated.
- `seed`: Sets a seed for stochastic simulations. Stochastic simulations with the same seed generate identical results.
A full list of solver options can be found [here](https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/).

### [Plotting options](@id simulation_intro_plot_options)
The Plots package provides a wide range of *plot attributes* to customise plots. E.g. to plot a solution with a thicker, dashed line, set the colors to green (for $X$) and purple (for $Y$), and also set the xguide to "Time", we use:
```@example simulation_intr_1
plot(sol; lw = 6, linestyle = :dash, color = [:green :purple], xguide = "Time")
```
Here we note that, when providing different arguments to different trajectories (i.e. here designating different colors for $X$ and $Y$), we use vector notation but without `,` (in practise, this creates a matrix, but where the length of one dimension is one).

Plot attributes are described in more details [here](https://docs.juliaplots.org/latest/attributes/). A full list of plot attributes is provided [in](https://docs.juliaplots.org/latest/generated/attributes_series/) [these](https://docs.juliaplots.org/latest/generated/attributes_plot/) [four](https://docs.juliaplots.org/latest/generated/attributes_subplot/) [links](https://docs.juliaplots.org/latest/generated/attributes_axis/).

## [Performing SDE simulations using the chemical Langevin equation](@id simulation_intro_SDEs)
Below we introduce how to simulate Catalyst models with SDEs as generated by the chemical Langevin equation. All simulations are performed using the [StochasticDiffEq.jl](https://github.com/SciML/StochasticDiffEq.jl) package, which full documentation can be found [here](https://docs.sciml.ai/DiffEqDocs/stable/tutorials/sde_example/). 

SDE simulations are performed in a similar manner to ODE simulations. The only exception is that an `SDEProblem` is created (rather than an `ODEProblem`). Furthermore, the [StochasticDiffEq.jl](https://github.com/SciML/StochasticDiffEq.jl) package (rather than the OrdinaryDiffEq package) is required for performing simulations. Here we simulate the Brusselator model for the same parameter set as previously used:
```@example simulation_intr_1
using StochasticDiffEq
sprob = SDEProblem(brusselator, u0, tspan, ps)
sol = solve(sprob)
plot(sol)
```
we can see that while the simulation exhibit some fluctuations, it is very similar to the deterministic one. This suggests that the assumption of the reaction rate equations hold well for this example However, if we change ..., reducing the species amounts, and simulate the model again, we notice more pronounced stochastic fluctuations:
```@example simulation_intr_1


sprob = SDEProblem(brusselator, u0, tspan, ps)
sol = solve(sprob)
plot(sol)
```
this suggests that for this regime, the RRE does not hold, and the CLE is required. If we try to reduce amounts further:
```@example simulation_intr_1


sprob = SDEProblem(brusselator, u0, tspan, ps)
sol = solve(sprob)
plot(sol)
```
we note that the simulation terminates due to a suspected instability. When we plot the solution,we notice that it is frequently negative, and that it finishes before reaching the final time point ($t=50.0$). When this happens for SDE simulations, it is typically a sign that species amounts are so low that the assumptions of the CLE no longer hold. Ideally, this should be remedies by using jump simulations instead.

### [Scaling the noise in the chemical Langevin equation](@id simulation_intro_SDEs_noise_saling)


## [Performing jump simulations using stochastic chemical kinetics](@id simulation_intro_jumps)
During so-called jump simulations, a system's state changes only at discrete timepoints (due to so-called *jump events*), in between which it remains constant. These can be used to simulate CRNs. Here, the state of the system is the discrete-valued copy-numbers of each of the systems's species. These copy-numbers change due to the occurrence of reaction events (which correspond to jumps). The rule describing how jump simulations are generated from CRNs is called *stochastic chemical kinetics*. These types of simulations was primarily popularised by the *Gillespie* (or *stochastic simulation*) algorithm (which can be used to perform such simulations). Comparing to the deterministic case, Jump simulations are analogues to ODEs, stochastic chemical kinetics to the reaction rate equation, and the Gillespie algorithm to Euler's method.

Catalyst uses the [JumpProcesses.jl](https://github.com/SciML/JumpProcesses.jl) package to perform jump simulations. This section provides a brief introduction, with [JumpProcesses's documentation](https://docs.sciml.ai/JumpProcesses/stable/) providing a more throughout description of how these can be performed. A dedicated section giving advice on how to optimise jump simulation performance can be found [here](@ref ref).

Jump simulations are performed using so-called `JumpProblem`s. Unlike ODEs and SDEs (for which the corresponding problem types can be created directly) Jump simulations require first creating an intermediary `DiscreteProblem`. In this example we will simulate a simple [Brusselator](https://en.wikipedia.org/wiki/Brusselator) model. We first create our model, and sets initial conditions, time span, and parameter values. Please note that, since we simulate the exact copy-numbers of each species present in the system (and not concentrations, as for ODEs and SDEs), the initial condition is *integer-valued*.
```@example simulation_intr_3
using Catalyst
brusselator = @reaction_network begin
    A, ∅ --> X
    1, 2X + Y --> 3X
    B, X --> Y
    1, X --> ∅
end
u0 = [:X => 1, :Y => 10]
tspan = (0.0, 50.0)
ps = [:A => 1.0, :B => 4.0]
nothing # hide
```
Next, we bundle these into a `DiscreteProblem` (similarly to how `ODEProblem`s and `SDEProblem`s are created):
```@example simulation_intr_3
using JumpProcesses
dprob = DiscreteProblem(brusselator, u0, tspan, ps)
nothing # hide
```
This is then used as input to a `JumpProblem`. The `JumpProblem` also requires the CRN model as input.
```@example simulation_intr_3
jprob = JumpProblem(brusselator, dprob)
nothing # hide
```
This `JumpProblem` can now be simulated using `solve` (just like any other problem type).
```@example simulation_intr_3
sol = solve(jprob)
nothing # hide
```
If we plot the solution we can see how the system's state does not change continuously, but instead in discrete jumps (due to the occurrence of the individual reactions of the system).
```@example simulation_intr_3
plot(sol)
```

### [Designating aggregators and simulation methods for jump simulations](@id simulation_intro_jumps_solver_designation)
Jump simulations (just like ODEs and SDEs) are performed using solver methods. Again, as good defaults are selected, the user typically does not need to specify these. Unlike ODEs and SDEs, jump simulations are carried out by two different types of methods acting in tandem. First, an *aggregator* method is used to (after each reaction) determine the time to, and type of, the next reaction. Next, a simulation method is used to actually carry out the simulation.

Several different aggregators are available (a full list is provided [here](https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Jump-Aggregators-for-Exact-Simulation)). To designate a specific one, provide it as the third argument to the `JumpProblem`. E.g. to designate that Gillespie's direct method (`Direct`) should be used, use:
```@example simulation_intr_3
jprob = JumpProblem(brusselator, dprob, Direct())
nothing # hide
```
Especially for large system, the choice of aggregator is relevant for performant simulations. A guide for selecting aggregators is provided [here](@ref ref).

Next, a simulation method can be provided (like for ODEs and SDEs) as the second argument to `solve`. Primarily two alternatives are available, `SSAStepper` and `FunctionMap` (other alternatives are only relevant when jump simulations are combined with ODEs/SDEs, for more details on this, please read JumpProcesses's documentation). Generally, `FunctionMap` is used when at least one reaction rate depends on time (and `SSAStepper` otherwise). E.g. we can designate that the `FunctionMap` method should be used using:
```@example simulation_intr_3
sol = solve(jprob, FunctionMap())
nothing # hide
```
The default choice, however, is good, and designating such a method is generally not recommended.
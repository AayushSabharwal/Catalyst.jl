# The Reaction DSL
This tutorial covers some of the basic syntax for building chemical reaction
network models using Catalyst's domain specific language (DSL). Examples showing
how to both construct and solve ODE, SDE, and jump models are provided in [Basic
Chemical Reaction Network Examples](@ref). To learn more about the symbolic
[`ReactionSystem`](@ref)s generated by the DSL, and how to use them directly, see
the tutorial on [Symbolic Reaction Systems](@ref).

## Basic syntax

The `@reaction_network` macro allows the (symbolic) specification of reaction
networks with a simple format. Its input is a set of chemical reactions, and
from them it generates a symbolic [`ReactionSystem`](@ref) reaction network
object. The `ReactionSystem` can be used as input to ModelingToolkit
`ODEProblem`, `NonlinearProblem`, `SteadyStateProblem`, `SDEProblem`,
`JumpProblem`, and more. `ReactionSystem`s can also be incrementally extended as
needed, allowing for programmatic construction of networks and network
composition.

The basic syntax is:

```julia
rn = @reaction_network begin
  2.0, X + Y --> XY               
  1.0, XY --> Z1 + Z2            
end
```

where each line corresponds to a chemical reaction. Each reaction consists of a
reaction rate (the expression on the left hand side of  `,`), a set of
substrates (the expression in-between `,` and `-->`), and a set of products (the
expression on the right hand side of `-->`). The substrates and the products may
contain one or more reactants, separated by `+`. The naming convention for
these are the same as for normal variables in Julia.

The chemical reaction model is generated by the `@reaction_network` macro and
stored in the `rn` variable (a normal Julia variable, which does not need to be
called `rn`). It corresponds to a [`ReactionSystem`](@ref), a symbolic
representation of the chemical network.  The generated `ReactionSystem` can be
converted to a symbolic differential equation model via
```julia
osys  = convert(ODESystem, rn)
```

We can then convert the symbolic ODE model into a compiled, optimized
representation for use in the SciML ODE solvers by constructing an `ODEProblem`.
Creating an `ODEProblem` also requires our specifying the initial conditions for
the model. We do this by creating a mapping from each symbolic variable
representing a chemical species to its initial value
```julia
# define the symbolic variables
@variables t, X(t), Y(t), Z(t), XY(t), Z1(t), Z2(t)

# create the mapping
u0 = [X => 1.0, Y => 1.0, XY => 1.0, Z1 => 1.0, Z2 => 1.0]
```
Alternatively, we can create a mapping use Julia `Symbol`s for each variable, and then convert them to a mapping involving symbolic variables like
```julia
u0 = symmap_to_varmap(rn, [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0]) 
```
Given the mapping, we can then create an `ODEProblem` from our symbolic `ODESystem`
```julia
oprob = ODEProblem(osys, u0, tspan, [])
```

Catalyst provides a shortcut to avoid having to explicitly `convert` to an
`ODESystem` and/or use `symmap_to_varmap`, allowing direct construction 
of the `ODEProblem` like
```julia
u0 = [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0]
oprob = ODEProblem(rn, u0, tspan, [])
```

For more detailed examples, see the [Basic Chemical Reaction Network
Examples](@ref). The generated differential equations use the law of mass
action. For the above example, the ODEs are then

```math
\frac{d[X]}{dt} = -2 [X] [Y]\\
\frac{d[Y]}{dt} = -2 [X] [Y]\\
\frac{d[XY]}{dt} = 2 [X] [Y] - [XY]\\
\frac{d[Z1]}{dt}= [XY]\\
\frac{d[Z2]}{dt} = [XY]
```

## Defining parameters and species
Parameter values do not need to be set when the model is created. Components can
be designated as symbolic parameters by declaring them at the end:
```julia
rn = @reaction_network begin
  p, ∅ --> X
  d, X --> ∅
end p d
```
Parameters can only exist in the reaction rates (where they can be mixed with
reactants). All variables not declared after `end` will be treated as a chemical
species.

## Production, Destruction and Stoichiometry
Sometimes reactants are produced/destroyed from/to nothing. This can be
designated using either `0` or `∅`:
```julia
rn = @reaction_network begin
  2.0, 0 --> X
  1.0, X --> ∅
end
```
If several molecules of the same reactant are involved in a reaction, the
stoichiometry of a reactant in a reaction can be set using a number. Here, two
molecules of species `X` form the dimer `X2`:
```julia
rn = @reaction_network begin
  1.0, 2X --> X2
end
```
this corresponds to the differential equation:

```math
\frac{d[X]}{dt} = -[X]^2\\
\frac{d[X2]}{dt} = \frac{1}{2!} [X]^2
```

Other numbers than 2 can be used, and parenthesis can be used to reuse the same
stoichiometry for several reactants:
```julia
rn = @reaction_network begin
  1.0, X + 2(Y + Z) --> XY2Z2
end
```

Note, one can explicitly multiply by integer coefficients too, i.e.
```julia
rn = @reaction_network begin
  1.0, X + 2*(Y + Z) --> XY2Z2
end
```


## Arrow variants
A variety of unicode arrows are accepted by the DSL in addition to `-->`. All of
these work:  `>`, `→` `↣`, `↦`, `⇾`, `⟶`, `⟼`, `⥟`, `⥟`, `⇀`, `⇁`. Backwards
arrows can also be used to write the reaction in the opposite direction. For
example, these reactions are equivalent:
```julia
rn = @reaction_network begin
  1.0, X + Y --> XY               
  1.0, X + Y → XY      
  1.0, XY ← X + Y      
  1.0, XY <-- X + Y      
end
```

## Bi-directional arrows for reversible reactions
Bi-directional arrows, including bidirectional unicode arrows like ↔, can be
used to designate a reversible reaction. For example, these two models are
equivalent:
```julia
rn = @reaction_network begin
  2.0, X + Y --> XY             
  2.0, X + Y <-- XY          
end
rn = @reaction_network begin
  (2.0,2.0), X + Y <--> XY               
end
```
If the reaction rates in the backward and forward directions are different, they
can be designated in the following way:
```julia
rn = @reaction_network begin
  (2.0,1.0) X + Y <--> XY               
end
```
which is identical to
```julia
rn = @reaction_network begin
  2.0, X + Y --> XY             
  1.0, X + Y <-- XY          
end
```

## Combining several reactions in one line
Several similar reactions can be combined in one line by providing a tuple of
reaction rates and/or substrates and/or products. If several tuples are provided,
they must all be of identical length. These pairs of reaction networks are all
identical:
```julia
rn1 = @reaction_network begin
  1.0, S --> (P1,P2)               
end
rn2 = @reaction_network begin
  1.0, S --> P1     
  1.0, S --> P2
end
```
```julia
rn1 = @reaction_network begin
  (1.0,2.0), (S1,S2) --> P             
end
rn2 = @reaction_network begin
  1.0, S1 --> P     
  2.0, S2 --> P
end
```
```julia
rn1 = @reaction_network begin
  (1.0,2.0,3.0), (S1,S2,S3) → (P1,P2,P3)        
end
rn2 = @reaction_network begin
  1.0, S1 --> P1
  2.0, S2 --> P2   
  3.0, S3 --> P3  
end
```
This can also be combined with bi-directional arrows, in which case separate
tuples can be provided for the backward and forward reaction rates.
These reaction networks are identical
```julia
rn1 = @reaction_network begin
 (1.0,(1.0,2.0)), S <--> (P1,P2)  
end
rn2 = @reaction_network begin
  1.0, S --> P1
  1.0, S --> P2
  1.0, P1 --> S   
  2.0, P2 --> S
end
```

## Variable reaction rates
Reaction rates do not need to be a single parameter or a number, but can also be
expressions depending on time or the current concentration of other species
(when, for example, one species can activate the production of another). For
instance, this is a valid notation:
```julia
rn = @reaction_network begin
  k*X, Y --> ∅
end k
```
and will have `Y` degraded at rate

```math
\frac{d[Y]}{dt} = -k[X][Y].
```

Note, this is actually equivalent to the reaction
```julia
rn = @reaction_network begin
  k, X + Y --> X
end k
```
in the resulting generated ODESystem, **however**, the latter `Reaction` will be
classified as [`ismassaction`](@ref) and the former will not, which can impact
optimizations used in generating `JumpSystem`s. For this reason, it is
recommended to use the latter representation when possible.

Most expressions and functions are valid reaction rates, e.g.:
```julia
using SpecialFunctions
rn = @reaction_network begin
  2.0*X^2, 0 --> X + Y
  t*gamma(Y), X --> ∅
  pi*X/Y, Y → ∅
end
```
where here `t` always denotes Catalyst's time variable. Please note that many
user-defined functions can be called directly, but others will require
registration with Symbolics.jl ([see the faq](@ref user_functions)).

## Naming the generated `ReactionSystem`
ModelingToolkit uses system names to allow for compositional and hierarchical
models. To specify a name for the generated `ReactionSystem` via the
`reaction_network` macro, just place the name before `begin`:
```julia
rn = @reaction_network production_degradation begin
  p, ∅ --> X
  d, X --> ∅
end p d
ModelingToolkit.nameof(rn) == :production_degradation
```

## Pre-defined functions
Hill functions and a Michaelis-Menten function are pre-defined and can be used
as rate laws. Below, the pair of reactions within `rn1` are equivalent, as are
the pair of reactions within `rn2`:
```julia
rn1 = @reaction_network begin
  hill(X,v,K,n), ∅ --> X
  v*X^n/(X^n+K^n), ∅ --> X
end v K n
rn2 = @reaction_network begin
  mm(X,v,K), ∅ --> X
  v*X/(X+K), ∅ --> X
end v K
```
Repressor Hill (`hillr`) and Michaelis-Menten (`mmr`) functions are also
provided:
```julia
rn1 = @reaction_network begin
  hillr(X,v,K,n), ∅ --> X
  v*K^n/(X^n+K^n), ∅ --> X
end v K n
rn2 = @reaction_network begin
  mmr(X,v,K), ∅ --> X
  v*K/(X+K), ∅ --> X
end v K
```

Please see the API [Rate Laws](@ref) section for more details.

## Interpolation of Julia Variables 
The DSL allows Julia variables to be interpolated for the network name, within rate constant expressions, or for species within the reaction. For example, 
```julia
@parameters k
@variables t, A(t)
spec = A
rate = k*A
name = :network
rn = @reaction_network $name begin
    $rate*B, 2*$spec + B --> $spec + C
  end
```
gives
```
Model network with 1 equations
States (3):
  A(t)
  B(t)
  C(t)
Parameters (1):
  k
```
with 
```julia
reactions(rn)
```
giving
```
1-element Vector{Reaction}:
 k*A(t)*B(t), 2A + B --> A + C
```
*As the parameter `k` was pre-defined and appears via interpolation, we did not
need to declare it at the end of the `@reaction_network` macro.*

Note, when using interpolation expressions like `2$spec` won't work; the
multiplication symbol must be explicitly included like `2*$spec`.
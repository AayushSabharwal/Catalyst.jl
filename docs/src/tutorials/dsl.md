# The Reaction DSL
This tutorial covers some of the basic syntax for building chemical reaction
network models using Catalyst's domain specific language (DSL). Examples showing
how to both construct and solve ODE, SDE, and jump models are provided in [Basic
Chemical Reaction Network Examples](@ref). To learn more about the symbolic
[`ReactionSystem`](@ref)s generated by the DSL, and how to use them directly, see
the tutorial on [Programmatic Construction of Symbolic Reaction Systems](@ref).

We first load the needed packages for the code in the tutorial to run
```@example tut2
using Catalyst
```

## [Basic syntax](@id basic_examples)

The `@reaction_network` macro allows the (symbolic) specification of reaction
networks with a simple format. Its input is a set of chemical reactions, and
from them it generates a symbolic [`ReactionSystem`](@ref) reaction network
object. The `ReactionSystem` can be used as input to ModelingToolkit
`ODEProblem`, `NonlinearProblem`, `SteadyStateProblem`, `SDEProblem`,
`JumpProblem`, and more. `ReactionSystem`s can also be incrementally extended as
needed, allowing for programmatic construction of networks and network
composition.

The basic syntax is:

```@example tut2
rn = @reaction_network begin
  2.0, X + Y --> XY
  1.0, XY --> Z1 + Z2
end
```
where each line of the [`@reaction_network`](@ref) macro corresponds to a
chemical reaction. Each reaction consists of a reaction rate (the expression on
the left hand side of  `,`), a set of substrates (the expression in-between `,`
and `-->`), and a set of products (the expression on the right hand side of
`-->`). The substrates and the products may contain one or more reactants,
separated by `+`. The naming convention for these are the same as for normal
variables in Julia.

The chemical reaction model is generated by the `@reaction_network` macro and
stored in the `rn` variable (a normal Julia variable, which does not need to be
called `rn`). It corresponds to a [`ReactionSystem`](@ref), a symbolic
representation of the chemical network.  The generated `ReactionSystem` can be
converted to a symbolic differential equation model via
```@example tut2
osys  = convert(ODESystem, rn)
```

We can then convert the symbolic ODE model into a compiled, optimized
representation for use in the SciML ODE solvers by constructing an `ODEProblem`.
Creating an `ODEProblem` also requires our specifying the initial conditions for
the model. We do this by creating a mapping from each symbolic variable
representing a chemical species to its initial value
```@example tut2
# define the symbolic variables
@variables t, X(t), Y(t), Z(t), XY(t), Z1(t), Z2(t)

# create the mapping
u0 = [X => 1.0, Y => 1.0, XY => 1.0, Z1 => 1.0, Z2 => 1.0]
```
Alternatively, we can create a mapping use Julia `Symbol`s for each variable,
and then convert them to a mapping involving symbolic variables like
```@example tut2
u0 = symmap_to_varmap(rn, [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0])
```
Given the mapping, we can then create an `ODEProblem` from our symbolic `ODESystem`
```@example tut2
tspan = (0.0, 1.0)  # the time interval to solve on
oprob = ODEProblem(osys, u0, tspan, [])
```

Catalyst provides a shortcut to avoid having to explicitly `convert` to an
`ODESystem` and/or use `symmap_to_varmap`, allowing direct construction
of the `ODEProblem` like
```@example tut2
u0 = [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0]
oprob = ODEProblem(rn, u0, tspan, [])
```

For more detailed examples, see the [Basic Chemical Reaction Network
Examples](@ref).

## Defining parameters and species
Parameter values do not need to be set when the model is created:
```@example tut2
rn = @reaction_network begin
  p, ∅ --> X
  d, X --> ∅
end
```
All symbols that does not appear as a reactant in a reaction is designated by Catalyst as a parameter. In this example `X` appear as a reactant, but not `p` and `d`. Hence `p` and `d` are designated as parameters. It is possible to manually set what should be considered a species or parameter This is described towards the end of this tutorial.

## Production, Destruction and Stoichiometry
Sometimes reactants are produced/destroyed from/to nothing. This can be
designated using either `0` or `∅`:
```@example tut2
rn = @reaction_network begin
  2.0, 0 --> X
  1.0, X --> ∅
end
```
If several molecules of the same reactant are involved in a reaction, the
stoichiometry of a reactant in a reaction can be set using a number. Here, two
molecules of species `X` form the dimer `X2`:
```@example tut2
rn = @reaction_network begin
  1.0, 2X --> Y
end
```
this corresponds to the differential equation:
```@example tut2
convert(ODESystem, rn)
```
Other numbers than 2 can be used, and parenthesis can be used to reuse the same
stoichiometry for several reactants:
```@example tut2
rn = @reaction_network begin
  1.0, X + 2(Y + Z) --> W
end
```
Note, one can explicitly multiply by integer coefficients too, i.e.
```@example tut2
rn = @reaction_network begin
  1.0, X + 2*(Y + Z) --> W
end
```

## Arrow variants
A variety of unicode arrows are accepted by the DSL in addition to `-->`. All of
these work:  `>`, `→` `↣`, `↦`, `⇾`, `⟶`, `⟼`, `⥟`, `⥟`, `⇀`, `⇁`. Backwards
arrows can also be used to write the reaction in the opposite direction. For
example, these reactions are equivalent:
```@example tut2
rn = @reaction_network begin
  1.0, X + Y --> XY
  1.0, X + Y → XY
  1.0, XY ← X + Y
  1.0, XY <-- X + Y
end
```

## Bi-directional arrows for reversible reactions
Bi-directional arrows, including bidirectional unicode arrows like ↔, can be
used to designate a reversible reaction. For example, these two models are
equivalent:
```@example tut2
rn = @reaction_network begin
  2.0, X + Y --> XY
  2.0, X + Y <-- XY
end
```
```@example tut2
rn2 = @reaction_network begin
  (2.0,2.0), X + Y <--> XY
end
```

If the reaction rates in the backward and forward directions are different, they
can be designated in the following way:
```@example tut2
rn = @reaction_network begin
  (2.0,1.0), X + Y <--> XY
end
```
which is identical to
```@example tut2
rn = @reaction_network begin
  2.0, X + Y --> XY
  1.0, X + Y <-- XY
end
```

## Combining several reactions in one line
Several similar reactions can be combined in one line by providing a tuple of
reaction rates and/or substrates and/or products. If several tuples are provided,
they must all be of identical length. These pairs of reaction networks are all
identical.

Pair 1:
```@example tut2
rn1 = @reaction_network begin
  1.0, S --> (P1,P2)
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S --> P1
  1.0, S --> P2
end
```
Pair 2:
```@example tut2
rn1 = @reaction_network begin
  (1.0,2.0), (S1,S2) --> P
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S1 --> P
  2.0, S2 --> P
end
```
Pair 3:
```@example tut2
rn1 = @reaction_network begin
  (1.0,2.0,3.0), (S1,S2,S3) → (P1,P2,P3)
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S1 --> P1
  2.0, S2 --> P2
  3.0, S3 --> P3
end
```
This can also be combined with bi-directional arrows, in which case separate
tuples can be provided for the backward and forward reaction rates.
These reaction networks are identical
```@example tut2
rn1 = @reaction_network begin
 (1.0,(1.0,2.0)), S <--> (P1,P2)
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S --> P1
  1.0, S --> P2
  1.0, P1 --> S
  2.0, P2 --> S
end
```

## Variable reaction rates
Reaction rates do not need to be a single parameter or a number, but can also be
expressions depending on time or the current concentration of other species
(when, for example, one species can activate the production of another). For
instance, this is a valid notation:
```@example tut2
rn = @reaction_network begin
  1.0, X --> ∅
  k*X, Y --> ∅
end
```
corresponding to the ODE model
```@example tut2
convert(ODESystem, rn)
```

With respect to the corresponding mass action ODE model, this is actually
equivalent to the reaction system
```@example tut2
rn = @reaction_network begin
  1.0, X --> ∅
  k, X + Y --> X
end k
```
```@example tut2
convert(ODESystem, rn)
```
!!! note
    While the ODE models corresponding to the preceding two reaction systems are
    identical, in the latter example the `Reaction` will be classified as
    [`ismassaction`](@ref) while in the former it will not, which can impact optimizations
    used in generating `JumpSystem`s. For this reason, it is recommended to use the
    latter representation when possible.

Most expressions and functions are valid reaction rates, e.g.:
```@example tut2
using SpecialFunctions
rn = @reaction_network begin
  2.0*X^2, 0 --> X + Y
  t*gamma(Y), X --> ∅
  pi*X/Y, Y → ∅
end
```
where here `t` always denotes Catalyst's time variable. Please note that many
user-defined functions can be called directly, but others will require
registration with Symbolics.jl ([see the faq](@ref user_functions)).

## Naming the generated `ReactionSystem`
ModelingToolkit uses system names to allow for compositional and hierarchical
models. To specify a name for the generated `ReactionSystem` via the
`reaction_network` macro, just place the name before `begin`:
```@example tut2
rn = @reaction_network production_degradation begin
  p, ∅ --> X
  d, X --> ∅
end
ModelingToolkit.nameof(rn) == :production_degradation
```

## Pre-defined functions
Hill functions and a Michaelis-Menten function are pre-defined and can be used
as rate laws. Below, the pair of reactions within `rn1` are equivalent, as are
the pair of reactions within `rn2`:
```@example tut2
rn1 = @reaction_network begin
  hill(X,v,K,n), ∅ --> X
  v*X^n/(X^n+K^n), ∅ --> X
end
```
```@example tut2
rn2 = @reaction_network begin
  mm(X,v,K), ∅ --> X
  v*X/(X+K), ∅ --> X
end
```
Repressor Hill (`hillr`) and Michaelis-Menten (`mmr`) functions are also
provided:
```@example tut2
rn1 = @reaction_network begin
  hillr(X,v,K,n), ∅ --> X
  v*K^n/(X^n+K^n), ∅ --> X
end
```
```@example tut2
rn2 = @reaction_network begin
  mmr(X,v,K), ∅ --> X
  v*K/(X+K), ∅ --> X
end
```

Please see the API [Rate Laws](@ref) section for more details.

## Manual designation of network species and parameters
The `@reaction_network` macro automatically designated symbols used in the macro as wither parameters of species. However, sometimes the user might want to manually override this selection. E.g one might want something to be considered as a species, even if it neither appears as a reaction substrate or product. In the following network
```@example tut2
rn = @reaction_network begin
  k*X, Y --> 0
end
```
`X` (as well as `k`) will be considered a parameter. 

By using the `@species` and ` @parameters` options within the `@reaction_network` macro, one can manually declare what should be considered a species or parameter. E.g in:
```@example tut2
rn = @reaction_network begin
  @species X(t) Y(t)
  k*X, Y --> 0
end
```
`X` and `Y` are set as species. Please note that when declaring species using the `@species` option, their dependant variable (almost always `t`) also needs to be desiganted. Similarly 
```@example tut2
rn = @reaction_network begin
  @parameters k
  k*X, Y --> 0
end
```
designates that `k` (and only `k`) should be considered a parameter. However, in this case the DSL does not know what to do with `X`, and throws an error. Instead, it is possible to use both options simultaneously:
```@example tut2
rn = @reaction_network begin
  @species X(t) Y(t)
  @parameters k
  k*X, Y --> 0
end
```
Here, `X` and `Y` are designated as species and `k` as a parameter.

Another use of the `@species` and ` @parameters` options is that they enable the user to set the *order* in which the parameters (or species) appear in their respective vector. It should be noted that it is strongly recommended to write code that does not depend on this order. However, if required to do so, the option exists. Consider the following network:
```@example tut2
rn = @reaction_network begin
  d2, X2 --> 0
  d1, X1 --> 0
end
```
If we consider the species and parameter vectors:
```
species(rn)
```
```
parameters(rn)
```
we note that they are ordered as `[X2(t) ,X1(t)]` and `[d2, d1]`. If one which to change the order, it can be done through:
```@example tut2
rn = @reaction_network begin
  @species X1 X2
  @parameters d1 d2
  d2, X2 --> 0
  d1, X1 --> 0
end
```
if we now check the two vectors, we see that the order has changed:
```
species(rn)
```
```
parameters(rn)
```
It should be noted if further modifications are made to a reaction network, the ordering set here cannot be guaranteed.


Finally, if prefered, the `@species` and `@parameters` options can also be used in `begin ... end` block form:
```
```@example tut2
rn = @reaction_network begin
    @parameters begin
        X1
        X2
    end
    @species begin
        d1(t)
        d2(t)
    end
  d2, X2 --> 0
  d1, X1 --> 0
end
```
especially when declaring defalt values (next section), this can make code clearer.


## Set default initial condition and parameter values
When using the `@species` and ` @parameters` options to declare species and/or parameters, one can also provide initial conditions for each component:
```@example tut2
rn = @reaction_network begin
  @species X(t)=1.0
  @parameters p=1.0, d=0.1
  p, 0 --> X
  d, X -->
end
```
the system can now be simulated without providing initial conditions or parameter values:
```@example tut2
using DifferentiaLEquations, Plots
u0 = []
tspan = (0.0,10.0)
p = []
oprob = ODEProblem(rn,u0,tspan,p)
sol = solve(oprob)
plot(sol)
```

When providing default values, it is possible to do so for only a subset of the species or parameters:
```@example tut2
rn = @reaction_network begin
  @species X(t)
  @parameters p=1.0, d
  p, 0 --> X
  d, X -->
end

u0 = [:X => 1.0]
tspan = (0.0,10.0)
p = [:p => 1.0]
oprob = ODEProblem(rn,u0,tspan,p)
sol = solve(oprob)
plot(sol)
```

Finally, even if a default value is provided, this can be overridden through the vectors parsed to the differential equation problem:
```
u0 = [:X => 1.0]
tspan = (0.0,10.0)
p = [:p => 1.0, :d => 0.5]
oprob = ODEProblem(rn,u0,tspan,p)
sol = solve(oprob)
plot(sol)
```


## Interpolation of Julia variables
The DSL allows Julia variables to be interpolated for the network name, within
rate constant expressions, or for species/stoichiometry within reactions. Using
the lower-level symbolic interface we can then define symbolic variables and
parameters outside of the macro, which can then be used within expressions in
the DSL (see the [Programmatic Construction of Symbolic Reaction Systems](@ref)
tutorial for details on the lower-level symbolic interface). For example,
```@example tut2
@parameters k α
@variables t, A(t)
spec = A
par = α
rate = k*A
name = :network
rn = @reaction_network $name begin
    $rate*B, 2*$spec + $par*B --> $spec + C
  end
```
As the parameters `k` and `α` were pre-defined and appeared via interpolation,
we did not need to declare them at the end of the `@reaction_network` macro,
i.e. they are automatically detected as parameters:
```@example tut2
parameters(rn)
```
as are the species coming from interpolated variables
```@example tut2
species(rn)
```

!!! note
    When using interpolation, expressions like `2$spec` won't work; the
    multiplication symbol must be explicitly included like `2*$spec`.